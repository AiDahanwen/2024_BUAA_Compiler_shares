# 优化文档

22373321-张瀚文

受限于数据库大作业和期末理论考试，我的优化只写了一个寄存器分配。因此我将对这部分的原理等进行详细展开，并同时记录困扰我的bug，希望能给在看的各位带来一点启发。

## 原理

寄存器分配属于中端优化。在获得中间代码后，根据中间代码分析计算变量之间的冲突关系，线性地进行寄存器分配。计算寄存器和值的对应关系信息传给后端，进而后端生成代码时就会用到所分配的寄存器。我没有使用最正规的图着色法分析，一来时间紧张只能选择trade-off，二来正如理论课中所说，一些基本的优化就能带来非常明显的效果，越往后不仅代价越大，且效果较为细微。

个人认为优化的一个核心就是：如何根据自己的代码架构，将理论的算法转化为代码，且达到预期效果。因为理论的算法理解起来是不困难的，难的是使用。下面的记录也会包含这一点。

### CFG

CFG也就是理论中所学的流图。在CFG阶段需要计算出所有基本块的前驱后继关系，便于第二阶段的活跃变量分析。除此之外还要计算出支配关系，便于寄存器分配决策时使用。

+ 前驱后继关系

  我使用的中间代码是LLVM_IR形式，在中间代码生成时已经显式地做好了基本块的划分。保证了每个基本块如果有后继关系，则基本块的最后一条有效指令必定是跳转指令。

  因此，需要做的工作就是遍历每一个函数中的每一个基本块，找到其产生跳转的指令，从指令中拿到前驱块和后继块的信息，储存起来，待扫描完毕后，将信息封装在基本块中，便于后续取用。

  具体框架如下图所示：

  ````java
  for(Funciton f : functions){
  	for(Basic block : f.getBlocks()){
  		//...找到前驱后继关系
  	}
      for(Basic block : f.getBlocks()){
          block.set...//存储前驱后继关系
      }
      f.set..//函数存储所有基本块的前驱后继关系
  }
  ````

+ 支配关系

  根据优化教程，这里使用迭代计算，根据某基本块的dom是某基本块所有前驱的dom的交集加上自己本身的策略进行更新，直到基本块的dom集合不再发生变化。

  注意最后要把计算出的支配关系封存在基本块中，包括支配和被支配关系。

### 活跃变量分析

根据理论部分知识，我们知道：

![image-20241219195924233](C:\Users\28952\AppData\Roaming\Typora\typora-user-images\image-20241219195924233.png)

因此，首先计算出每个基本块的def/use集合，再倒序计算in和out集合，直到每个基本块的in和out集合不产生变化。

+ 计算def/use

  如何计算def/use？手动计算是很容易的，使用点在定义点之前就是use，反之就是def。在转化为代码的过程中也可以借鉴这个思路。

  首先建立一个空的def集合和use集合，接着扫描基本块中的每条指令，首先遍历这个指令的operand，形象的说，对应这个instr使用的变量。若此时def集合中没有这个operand，则说明是先使用，加在use集合里。这样扫描一遍一个指令后，如果instr本身没有在use里，且是有左值的instr，即instr是一个可以定义变量的instr，则将其加入def集中。

  ```java
  def = new HashSet<>();
  use = new HashSet<>();
  for (Instr instr : instrList) {
      //先使用后定义
      for (Value value : instr.operands) {
          if (/**/)) {
            use.add(value);
          }
      }
      //先定义后使用
      if (/**/) {
          def.add(instr);
      }
  }
  ```

+ 计算in/out

  获得def/use后就可以计算in/out集合。此时我们可以直接使用上述ppt里的公式。注意倒叙计算以及判断in/out是否变化即可。java类的hashset有类似的集合运算，选取数据结构的时候可以考虑。

  ```java
  while (!notChange) { 
      notChange = true;
      int size = blocks.size();
      for (int i = size - 1; i >= 0; i--) {
          BasicBlock b = blocks.get(i);
          HashSet<Value> outOfb = //...;
          blockOutMap.put(b, outOfb);
          HashSet<Value> defOfb = b.getDef();
          HashSet<Value> useOfb = b.getUse();
          HashSet<Value> newIn = //...
          HashSet<Value> prevIn = blockInMap.get(b);
          if (!prevIn.equals(newIn)) {
              blockInMap.put(b, newIn);
              notChange = false;
          }
      }
  }
  ```

### 分配

以基本块为单位进行寄存器分配。选取`$t0-$t9`寄存器作为寄存器池。

首先遍历所有指令，计算基本块中的变量在块中的最后一次出现的位置。

其次再次遍历，当一个指令的operand在基本块最后一次使用，且基本块的out集不包含这个operand的时候，暂时释放这个变量的寄存器。否则，如果这个指令属于有左值的，也就是能定义变量的instr，则为其分配寄存器。分配时检查\$t0-t9有无空闲寄存器，若有则直接分配，否则默认分配`$t0`寄存器。

此轮遍历结束后，遍历其直接支配的基本块。为了最大程度使用寄存器，可以先记录寄存器和值的映射关系，然后将其释放，以免影响后续基本块中寄存器的分配。

最后，我们将后继不再使用，且不在当前基本块定义的变量的映射关系恢复。

这样，我们就得到了一个基本块的寄存器和值的映射关系，当一个函数所有基本块都分配完后，封存该信息，用于后端代码生成。

## BUG

+ CFG部分

  很隐蔽的一个bug。

  该bug的外在表现是：代码中一个不应该释放的寄存器在没到最后使用的时候被释放掉了。进而导致后续取这个寄存器里面的值的时候取出的不是原来的地址。因此总是出现address out of range的bug。

  初始时认为是寄存器分配的问题，但实际上经过最后助教的帮助和自己的调试，发现问题出在**流图**上。

  流图是优化必不可少的一步，其中很基本的一个是计算基本块的前驱后继关系，以备后续使用。

  根据教程，这一步其实是很好计算的，只需要找到每个基本块的跳转指令，根据跳转指令的目标块记录关系就行——问题就出在这里。

  我的代码是没做死代码删除的，所以在一些情况下，我的llvm里面会出现这样的情况：

  ```LLVM
  block_0:
  br label %block_1
  br label %block_0
  ```

  而在计算流图的时候，我找的是每个基本块的最后一条指令是不是跳转指令。

  因此，当出现如上情况的时候，我记录的`block_0`的后继块是`block_0`，而不是正确的`block_1`。

  这个问题是非常致命的，因为前驱后继关系是活跃变量分析的基础，而分配寄存器又是依据活跃变量及其之间的关系决定如何分配的。

  于是在基本块`BasicBlock`中添加一个找到第一个跳转指令的函数。问题顺利解决。

  后续我还分析了一下为什么我的代码中会出现两条br直接跳转的指令相邻的情况，原来是因为此时for循环中判断条件和循环量变化两部分都是空导致的。

  下面附上这个对应的样例(简化版，防止de两千多行的bug)

  ```C
  int main(){
      int a = 0;
      int d = 4, c= 1;
      int i;
      c = a + d;
      i = 0;
      for(i = 0; ;){
          break;
      }
      if(d >= a){
      };
      return 0;
  }
  ```



